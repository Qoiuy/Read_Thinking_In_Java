# Read_Thinking_In_Java
阅读 Java编程思想的读后感。。

《THINKING IN JAVA》 中 文 版 1

||[]()||

| 章节 | 目录及链接       |是否完成读后感|
|:-------:|:--------------|:---------:|
||第 1 章 对 象 入 门||
|1.1|[抽象的进步](https://github.com/Qoiuy/Read_Thinking_In_Java/blob/master/chapter1/section1.0.md)||
11 27
12 对象的接口28
13 实现方案的隐藏 29
14 方案的重复使用 30
15 继承:重新使用接口 30
151 改善基础类  30
152 等价与类似关系 31
16 多形对象的互换使用 31
161 动态绑定 32
162 抽象的基础类和接口 32
17 对象的创建和存在时间 33
171 集合与继承器  33
172 单根结构 34
173 集合库与方便使用集合 35
174 清除时的困境:由谁负责清除?  35
18 违例控制:解决错误 36
19 多线程 37
110 永久性 37
111 Java 和因特网37
1111 什么是 Web?  37
1112 客户端编程(注释8)  38
1113 服务器端编程  41
1114 一个独立的领域:应用程序 41
112 分析和设计 42
1121 不要迷失 42
1122 阶段 0:拟出一个计划 42
1123 阶段 1 :要制作什么?  43
1124 阶段 2:如何构建?  43
1125 阶段 3:开始创建  44
1126 阶段 4:校订  44
1127 计划的回报  45
113 Java 还是 C++?45
 
17第 2 章 一 切 都 是 对 象 46
21 用句柄操纵对象 46
22 所有对象都必须创建 46
221 保存到什么地方 46
222 特殊情况:主要类型 47
223 Java 的数组  48
23 绝对不要清除对象 48
231 作用域  48
232 对象的作用域  49
24 新建数据类型:类 49
241 字段和方法  49
25 方法、自变量和返回值 50
251 自变量列表  51
26 构建 Java 程序 52
261 名字的可见性  52
262 使用其他组件  52
263 static 关键字 52
27 我们的第一个 Java 程序53
28 注释和嵌入文档 55
281 注释文档 56
282 具体语法 56
283 嵌入 HTML 56
284 @see:引用其他类  57
285 类文档标记  57
286 变量文档标记  57
287 方法文档标记  57
288 文档示例 58
29 编码样式 59
210 总结59
211 练习59
第 3 章 控 制 程 序 流 程 60
31 使用 Java 运算符 60
311 优先级  60
312 赋值 60
313 算术运算符  62
314 自动递增和递减 64
315 关系运算符  65
316 逻辑运算符  66
317 按位运算符  68
318 移位运算符  68
319 三元 if-else 运算符  71
3110 逗号运算符  72
3111 字串运算符 + 72
3112 运算符常规操作规则  72
3113 造型运算符  73
3114 Java 没有“sizeof”  74
3115 复习计算顺序  75
3116 运算符总结  75
32 执行控制 84
321 真和假  84
322 if-else 84
323 反复 85
 
18324 do-while 85
325 for 86
326 中断和继续  87
327 开关 91
33 总结  94
34 练习 94
第 4 章 初 始 化 和 清 除 95
41 用构建器自动初始化 95
42 方法过载 96
421 区分过载方法  97
422 主类型的过载  98
423 返回值过载  101
424 默认构建器  102
425 this 关键字  102
43 清除:收尾和垃圾收集  105
431 finalize()用途何在 105
432 必须执行清除  106
44 成员初始化 108
441 规定初始化  109
442 构建器初始化  111
45 数组初始化 116
451 多维数组 119
46 总结 121
47 练习 121
第 5 章 隐 藏 实 施 过 程 123
51 包:库单元 123
511 创建独一无二的包名 124
512 自定义工具库  126
513 利用导入改变行为  128
514 包的停用 130
52 Java 访问指示符  130
521 “友好的”  130
522 public:接口访问  131
523 private:不能接触! 132
524 protected:“友好的一种”  133
53 接口与实现 134
54 类访问  135
55 总结 136
56 练习 137
第 6 章 类再生  139
61 合成的语法 139
62 继承的语法  141
621 初始化基础类  143
63 合成与继承的结合  145
631 确保正确的清除 146
632 名字的隐藏  148
64 到底选择合成还是继承  149
65 protected  150
66 累积开发 151
67 上溯造型 151
671 何谓“上溯造型”? 152
68 final 关键字 152
681 final 数据 152
 
19682 final 方法 155
683 final 类 156
684 final 的注意事项  156
69 初始化和类装载 157
691 继承初始化  157
610 总结 158
611 练习 159
第 7 章 多形性  160
71 上溯造型 160
711 为什么要上溯造型  161
72 深入理解 162
721 方法调用的绑定 163
722 产生正确的行为 163
723 扩展性  165
73 覆盖与过载 168
74 抽象类和方法  169
75 接口 172
751 Java 的“多重继承” 174
752 通过继承扩展接口  176
753 常数分组 177
754 初始化接口中的字段 178
76 内部类  179
761 内部类和上溯造型  180
762 方法和作用域中的内部类  181
763 链接到外部类  186
764 static 内部类 187
765 引用外部类对象 189
766 从内部类继承  190
767 内部类可以覆盖吗? 190
768 内部类标识符  192
769 为什么要用内部类:控制框架 192
77 构建器和多形性 198
771 构建器的调用顺序  198
772 继承和 finalize()  199
773 构建器内部的多形性方法的行为  202
78 通过继承进行设计  204
781 纯继承与扩展  205
782 下溯造型与运行期类型标识 206
79 总结 208
710 练习 208
第 8 章 对象的容纳  209
81 数组 209
811 数组和第一类对象  209
812 数组的返回  212
82 集合 213
821 缺点:类型未知 213
83 枚举器(反复器)  217
84 集合的类型 220
841 Vector 220
842 BitSet 221
843 Stack  222
844 Hashtable 223
845 再论枚举器  228
 
2085 排序 229
86 通用集合库 232
87 新集合  233
871 使用 Collections 235
872 使用 Lists 238
873 使用 Sets  242
874 使用 Maps 244
875 决定实施方案  247
876 未支持的操作  253
877 排序和搜索  255
878 实用工具 259
88 总结 261
89 练习 262
第 9 章 违 例 差 错 控 制 263
91 基本违例 263
911 违例自变量  264
92 违例的捕获 264
921 try 块  264
922 违例控制器  265
923 违例规范 265
924 捕获所有违例  266
925 重新“掷”出违例  267
93 标准 Java 违例 270
931 RuntimeException 的特殊情况  270
94 创建自己的违例 271
95 违例的限制 274
96 用 finally 清除 276
961 用 finally 做什么  277
962 缺点:丢失的违例  279
97 构建器  280
98 违例匹配 283
981 违例准则 284
99 总结 284
910 练习 284
第 10 章 J AVA IO 系 统  285
101 输入和输出  285
1011 InputStream的类型  285
1012 OutputStream的类型  286
102 增添属性和有用的接口  286
1021 通过 FilterInputStream 从 InputStream里读入数据  287
1022 通过 FilterOutputStream 向 OutputStream 里写入数据  287
103 本身的缺陷:RandomAccessFile 288
104 File 类 288
1041 目录列表器  288
1042 检查与创建目录292
105 IO 流的典型应用 294
1051 输入流  296
1052 输出流  298
1053 快捷文件处理  298
1054 从标准输入中读取数据  300
1055 管道数据流  300
106 StreamTokenizer 300
 
211061 StringTokenizer  303
107 Java 11 的 IO 流 305
1071 数据的发起与接收  305
1072 修改数据流的行为  306
1073 未改变的类  306
1074 一个例子 307
1075 重导向标准 IO 310
108 压缩 311
1081 用 GZIP 进行简单压缩 311
1082 用 Zip 进行多文件保存 312
1083 Java 归档(jar)实用程序  314
109 对象序列化  315
1091 寻找类  318
1092 序列化的控制  319
1093 利用“持久性”326
1010 总结  332
1011 练习 332
第 11 章 运 行 期 类 型 鉴 定 333
111 对 RTTI 的需要  333
1111 Class 对象 334
1112 造型前的检查  337
112 RTTI 语法 342
113 反射:运行期类信息 343
1131 一个类方法提取器  344
114 总结 347
115 练习 348
第 12 章 传 递 和 返 回 对 象 349
121 传递句柄 349
1211 别名问题 349
122 制作本地副本351
1221 按值传递 351
1222 克隆对象 352
1223 使类具有克隆能力  353
1224 成功的克隆  353
1225 Objectclone()的效果  355
1226 克隆合成对象  356
1227 用 Vector 进行深层复制 358
1228 通过序列化进行深层复制 359
1229 使克隆具有更大的深度  361
12210 为什么有这个奇怪的设计  362
123 克隆的控制  363
1231 副本构建器  366
124 只读类  369
1241 创建只读类  370
1242 “一成不变”的弊端  371
1243 不变字串 373
1244 String 和 StringBuffer 类 374
1245 字串的特殊性  376
125 总结 376
126 练习 376
第十三 章 创 建 窗 口 和 程 序 片  378
131 为何要用 AWT ? 378
 
22132 基本程序片  379
1321 程序片的测试  380
1322 一个更图形化的例子  381
1323 框架方法的演示381
133 制作按钮 382
134 捕获事件 382
135 文本字段 384
136 文本区域 385
137 标签 386
138 复选框  387
139 单选钮  388
1310 下拉列表 389
1311 列表框 390
13111 handleEvent()  391
1312 布局的控制  393
13121 FlowLayout 393
13122 BorderLayout  393
13123 GridLayout 394
13124 CardLayout 394
13125 GridBagLayout396
1313 action 的替代品 396
1314 程序片的局限 400
13141 程序片的优点 401
1315 视窗化应用  401
13151 菜单 401
13152 对话框  404
1316 新型 AWT  408
13161 新的事件模型 409
13162 事件和接收者类型  410
13163 用 Java 11 AWT制作窗口和程序片  414
13164 再研究一下以前的例子  416
13165 动态绑定事件 431
13166 将事务逻辑与 UI 逻辑区分开  433
13167 推荐编码方法 435
1317 Java 11 用户接口 API 448
13171 桌面颜色  448
13172 打印 448
13173 剪贴板  454
1318 可视编程和 Beans456
13181 什么是 Bean 457
13182 用 Introspector 提取 BeanInfo 458
13183 一个更复杂的 Bean  463
13184 Bean 的封装  465
13185 更复杂的 Bean 支持 466
13186 Bean 更多的知识  466
1319 Swing 入门(注释7) 467
13191 Swing 有哪些优点  467
13192 方便的转换  467
13193 显示框架  468
13194 工具提示  469
13195 边框 469
13196 按钮 470
13197 按钮组  471
 
2313198 图标 472
13199 菜单 474
131910 弹出式菜单  477
131911 列表框和组合框 479
131912 滑杆和进度指示条  479
131913 树  480
131914 表格 482
131915 卡片式对话框 483
131916 Swing 消息框 485
131917 Swing 更多的知识 485
1320 总结 485
1321 练习 486
第 14 章 多线程 487
141 反应灵敏的用户界面  487
1411 从线程继承  489
1412 针对用户界面的多线程  490
1413 用主类合并线程493
1414 制作多个线程  495
1415 Daemon 线程  498
142 共享有限的资源 499
1421 资源访问的错误方法  499
1422 Java 如何共享资源 503
1423 回顾 Java Beans 506
143 堵塞 510
1431 为何会堵塞  510
1432 死锁  518
144 优先级  521
1441 线程组  525
145 回顾 runnable 530
1451 过多的线程  532
146 总结 535
147 练习 535
第 15 章 网 络 编 程 537
151 机器的标识  537
1511 服务器和客户机538
1512 端口:机器内独一无二的场所  539
152 套接字  539
1521 一个简单的服务器和客户机程序  539
153 服务多个客户 543
154 数据报  547
155 一个 Web 应用 551
1551 服务器应用  552
1552 NameSender程序片  556
1553 要注意的问题  560
156 Java 与 CGI 的沟通 560
1561 CGI 数据的编码 561
1562 程序片  562
1563 用 C++写的 CGI 程序 566
1564 POST 的概念  573
157 用 JDBC 连接数据库  576
1571 让示例运行起来 578
1572 查找程序的 GUI 版本 580
 
241573 JDBC API 为何如何复杂 582
158 远程方法 582
1581 远程接口概念  582
1582 远程接口的实施583
1583 创建根与干  585
1584 使用远程对象  585
1585 RMI 的替选方案  586
159 总结 586
1510 练习 586
第 16 章 设 计 范 式 588
1611 单子  588
1612 范式分类 589
162 观察器范式  590
163 模拟垃圾回收站  592
164 改进设计 595
1641 “制作更多的对象”  595
1642 用于原型创建的一个范式 597
165 抽象的应用  604
166 多重派遣 607
1661 实现双重派遣  607
167 访问器范式  612
168 RTTI 真的有害吗  618
169 总结 620
1610 练习 621
第 17 章 项 目  622
171 文字处理 622
1711 提取代码列表  622
1712 检查大小写样式633
172 方法查找工具639
173 复杂性理论  643
174 总结 649
175 练习 649
附 录 A 使用非 JAVA 代 码 650
A1 Java 固有接口  650
A11 调用固有方法  650
A12 访问 JNI 函数:JNIEnv 自变量 652
A13 传递和使用 Java 对象 653
A14 JNI 和 Java 异常  654
A15 JNI 和线程处理  655
A16 使用现成代码  655
A2 微软的解决方案  655
A3 J/Direct 655
A31 @dllimport 引导命令  656
A32 commswin32 包 657
A33 汇集 658
A34 编写回调函数  659
A35 其他 J/Direct 特性 659
A4 本原接口(RNI) 660
A41 RNI 总结 661
A5 Java/COM 集成 661
A51 COM 基础 662
A52 MS Java/COM 集成 663
 
25A53 用 Java 设计 COM 服务器  663
A54 用 Java 设计 COM 客户 665
A55 ActiveX/Beans 集成 666
A56 固有方法与程序片的注意事项 666
A6 CORBA  666
A61 CORBA 基础  666
A62 一个例子 667
A63 Java 程序片和 CORBA 671
A64 比较 CORBA 与 RMI  671
A7 总结 671
附 录 B 对 比 C++和 J AVA  672
附 录 C J AVA 编 程 规 则  677
附 录 D 性 能  679
D1 基本方法  679
D2 寻找瓶颈  679
D21 安插自己的测试代码  679
D22 JDK 性能评测[2]679
D23 特殊工具 680
D24 性能评测的技巧 680
D3 提速方法  680
D31 常规手段 680
D32 依赖语言的方法 680
D33 特殊情况 681
D4 参考资源  682
D41 性能工具 682
D4 2 Web 站点 682
D43 文章 682
D44 Java 专业书籍 683
D45 一般书籍 683
附 录 E 关 于 垃 圾 收 集 的 一 些 话  684
附 录 F 推 荐 读 物  686
 
 
